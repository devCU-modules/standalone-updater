<?php
define("INI_SYSTEM_CHECK_DISABLED", ini_get('disable_functions'));

if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'ini_set')) {
    ini_set("memory_limit", "160M");
    ini_set("set_time_limit", 0);
}

if (!strstr(INI_SYSTEM_CHECK_DISABLED, 'date_default_timezone_set')) {
    date_default_timezone_set('America/Los_Angeles');
}

include_once 'Unzip.php';

class StandaloneUpdateExecutor
{
    public function getLogfile()
    {
        return $this->getInstallSessionId() . 'log.txt';
    }

    public function log($log)
    {
        @file_put_contents($this->getLogfile(), $log . PHP_EOL);
    }

    public function getInstallSessionId()
    {
        return $_COOKIE['install_session_id'];
    }

    public function startSession()
    {
        if (!isset($_COOKIE['install_session_id'])) {
            setcookie('install_session_id', rand(2222,4444), time() + (1800), "/");
            $this->log('Starting the installation session..');
        }
    }

    public function setInstallVersion($version = 'latest')
    {
        setcookie('install_session_version', $version, time() + (1800), "/");
    }

    public function isStarted()
    {
        if (!isset($_COOKIE['install_session_id'])) {
            return false;
        }
        return true;
    }

    public function latestVersion() {
        $updateApi = 'https://update-dev.microweberapi.com/?api_function=get_download_link&get_last_version=1';
        $version = file_get_contents($updateApi);
        $version = json_decode($version, true);
        return $version;
    }

    public function latestDevVersion() {

        $latestDevVersionZip = 'http://updater.microweberapi.com/microweber-dev.zip';

        return ['url'=>$latestDevVersionZip];
    }

    public function startUpdating()
    {
        $version = 'latest';

        if (isset($_COOKIE['install_session_version'])  && $_COOKIE['install_session_version'] == 'dev') {
            $version = 'latest developers';
            $installVersion = $this->latestDevVersion();
        } else {
            $installVersion = $this->latestVersion();
            if (!$installVersion['url']) {
                echo "Can't update the version now.";
                return;
            }
        }

        $this->log('Downloading '.$version.' version of microweber.');

        $zipFile = time() . 'mw-app.zip';

        $downloadStatus = $this->downloadFile($installVersion['url'], $zipFile);

        if ($downloadStatus) {
            $this->log('The '.$version.' version of microweber is download successfully!');
        }

        $this->log('Unzipping the files...');

        $unzip = new Unzip();
        $unzip->extract(__DIR__ . DIRECTORY_SEPARATOR . $zipFile, __DIR__ . DIRECTORY_SEPARATOR . 'mw-app-unziped/', true);

        $this->log('Replacing the new files...');

        $replace = new StandaloneUpdateReplacer();
        $replace->start();

        $this->log(json_encode(['success'=>true, 'message'=>'Done! You are up to date!']));
    }

    public function downloadFile($url, $dest)
    {
        set_time_limit(0);
        $logFile = $this->getLogfile();
        $options = array(
            CURLOPT_FILE => is_resource($dest) ? $dest : fopen($dest, 'w'),
            CURLOPT_TIMEOUT => 600,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_VERBOSE => true,
            CURLINFO_HEADER_OUT => true,
            CURLOPT_URL => $url,
            CURLOPT_FAILONERROR => true, // HTTP code > 400 will throw curl error
        );
        if ($logFile) {
            $options[CURLOPT_STDERR] = fopen($logFile, 'a+');
            $options[CURLOPT_WRITEHEADER] = fopen($logFile, 'a+');
        }

        $ch = curl_init();

        curl_setopt_array($ch, $options);

        $return = curl_exec($ch);

        if ($return === false) {
            return curl_error($ch);
        } else {
            return true;
        }
    }
}

if (isset($_GET['format']) && $_GET['format'] == "json") {

    $json = [];
    header('Content-Type: application/json');

    if (isset($_GET['startSession']) && $_GET['startSession'] == 1) {
        $update = new StandaloneUpdateExecutor();
        $update->setInstallVersion($_GET['installVersion']);
        $json['start'] = $update->startSession();
    }

    if (isset($_GET['startUpdating']) && $_GET['startUpdating'] == 1) {
        $update = new StandaloneUpdateExecutor();
        $json['updating'] = $update->startUpdating();
    }

    if (isset($_GET['isStarted']) && $_GET['isStarted'] == 1) {
        $update = new StandaloneUpdateExecutor();
        $json['started'] = $update->isStarted();
    }

    if (isset($_GET['getLogfile']) && $_GET['getLogfile'] == 1) {
        $update = new StandaloneUpdateExecutor();
        $json['logfile'] = $update->getLogfile();
    }

    die(json_encode($json));
}

class StandaloneUpdateReplacer
{
    public $microweberPath;
    public $newMicroweberPath;

    public function __construct()
    {
        $this->microweberPath = dirname(dirname(dirname(__DIR__)));
        $this->newMicroweberPath = __DIR__ . DIRECTORY_SEPARATOR . 'mw-app-unziped';
    }

    public function start()
    {
        $newFilesForCopy = [];
        $newFilesForCopy = array_merge($newFilesForCopy, $this->getFilesFromPath( $this->newMicroweberPath . DIRECTORY_SEPARATOR . 'userfiles'.DIRECTORY_SEPARATOR.'templates'));
        $newFilesForCopy = array_merge($newFilesForCopy, $this->getFilesFromPath( $this->newMicroweberPath . DIRECTORY_SEPARATOR . 'userfiles'.DIRECTORY_SEPARATOR.'modules'));
        $newFilesForCopy = array_merge($newFilesForCopy, $this->getFilesFromPath( $this->newMicroweberPath . DIRECTORY_SEPARATOR . 'src'));
        $newFilesForCopy = array_merge($newFilesForCopy, $this->getFilesFromPath( $this->newMicroweberPath . DIRECTORY_SEPARATOR . 'vendor'));

        foreach($newFilesForCopy as $newFile) {

            $newFileFolder = dirname($this->microweberPath . $newFile['targetPath']);
            if (!is_dir($newFileFolder)) {
                mkdir_recursive($newFileFolder);
            }

            if (is_file($this->microweberPath . $newFile['targetPath'])) {
                if ($this->filesAreEqual($newFile['realPath'],$this->microweberPath . $newFile['targetPath'])) {
                    continue;
                }
            }

            if (is_file($this->microweberPath . $newFile['targetPath'])) {
                @unlink($this->microweberPath . $newFile['targetPath']);
            }

            copy($newFile['realPath'], $this->microweberPath . $newFile['targetPath']);

        }
    }

    public function filesAreEqual($a, $b)
    {
        $a = file_get_contents($a);
        $b = file_get_contents($b);

        $a = preg_replace('/\s+/', '', $a);
        $b = preg_replace('/\s+/', '', $b);

        $a = trim($a);
        $b = trim($b);

        if ($a == $b) {
            return true;
        }

        return false;
    }

    public function getFilesFromPath($path)
    {
        $filesMap = [];
        $files = new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($path, \RecursiveDirectoryIterator::SKIP_DOTS), \RecursiveIteratorIterator::CHILD_FIRST);
        foreach ($files as $fileinfo) {
            if (!$fileinfo->isDir()) {

                $targetPath = $fileinfo->getRealPath();
                $targetPath = str_replace($this->newMicroweberPath,'', $targetPath);

                $filesMap[] = ['realPath'=>$fileinfo->getRealPath(),'targetPath'=>$targetPath];
            }
        }
        return $filesMap;
    }
}
/*
$replace = new StandaloneUpdateReplacer();
$replace->start();*/
